<html>
  <style>
   body {
     background: #000;
   }

   .galaxy {
     margin: 1em;
   }

   .space-simulation {
     font-face: "Arial";
     font-size: 0.7em;
     color: #999;
   }

   .space-viewport {
     display: inline-block;
   }
   .control-panel {
     display: inline-block;
     vertical-align: top;
     padding: 1em;
   }

   .space-simulation form ul {
     list-style-type: none;
     padding-left: 0
   }

   .space-simulation form input {
     background: #000;
     font-size: 1em;
     color: #999;
     width: 3em;
     border-width: 1px;
   }
   .space-simulation label {
     vertical-align: middle;
     display: inline-block;
     margin-left: 0.5em;
     margin-right: 0.7em;
   }
   .space-simulation form input[type="checkbox"] {
     vertical-align: middle;
     width: auto;
     margin-left: 0;
     /* margin-bottom: 0
        margin-top: 0.2em; */
   }
   .space-simulation form button {
     background: #000;
     font-size: 1em;
     color: #999;
     border-width: 1px;
   }
  </style>

  <body>
    <div id="milky-simulation" class="space-simulation">
      <div>

        <div class="space-viewport">
          <canvas id="milky" class="galaxy" width="640" height="480"></canvas>
        </div>

        <div class="control-panel">
          <form>
            <p><b>Field</b></p>
            <ul>
              <li><label><input type="checkbox" name="drawFieldVector" checked>Vector</label></li>
              <li><label><input type="checkbox" name="drawFieldStrength">Strength</label></li>
            </ul>

            <p><b>Star</b></p>
            <ul>
              <li>Count <input type="text" name="starCount" autocomplete="off" /> </li>
              <li><label><input type="checkbox" name="drawStarTail" checked>Tail</label></li>
              <li><label><input type="checkbox" name="drawStarsLine">Snap</label></li>
            </ul>
          </form>
          <form>
            <button class="restart-simulation">Restart stars</button>
          </form>
        </div>

      </div>
    </div>


    <div>
      <canvas id="andromeda" class="galaxy" width="100" height="100"></canvas>
    </div>

  </body>

  <script>
   "use strict";

   // http://slicker.me/javascript/particles.htm inspired me to do this


   function Simulation({ id, space }) {
     const topElement = document.querySelector(`#${id}`);
     const restartButton = topElement.querySelector(`#${id} .restart-simulation`);

     const starCountInput = topElement.querySelector(`input[name="starCount"]`);
     const drawStarTailCheckbox = topElement.querySelector(`input[name="drawStarTail"]`);
     const drawFieldVectorCheckbox = topElement.querySelector(`input[name="drawFieldVector"]`);
     const drawFieldStrengthCheckbox = topElement.querySelector(`input[name="drawFieldStrength"]`);
     const drawStarsLineCheckbox = topElement.querySelector(`input[name="drawStarsLine"]`);

     const self = this;
     // Update config immediately on all input changes (checkbox, text field)
     topElement.querySelectorAll(`input`).forEach((element) => {
       element.addEventListener(
         "change", function(e) { return self.eventConfigChanged(e); },
       );
     });
     // Stop form from being submitted on <Return>
     topElement.querySelectorAll(`form`).forEach((element) => {
       element.addEventListener(
         "submit", function(e) { return event.preventDefault(); return false }, false,
       );
     });

     // Click button
     restartButton.addEventListener(
       "click", function(e) { return self.eventRestartClick(e); },
     );

     // Construct object
     this.id = id;
     this.space = space;

     this.eventConfigChanged = function(e) {
       event.preventDefault();

       const starCountInputValue = starCountInput.value;
       const starCount = parseInt(starCountInputValue , 10);
       if (isNaN(starCount)) {
         starCountInput.value = this.space.starCount;
       }
       else {
         this.space.starCount = starCount;
       }

       const drawStarTail = !! drawStarTailCheckbox.checked;
       this.space.setDrawStarTail(drawStarTail);

       const drawFieldVector = !! drawFieldVectorCheckbox.checked;
       this.space.drawFieldVector = drawFieldVector;

       const drawFieldStrength = !! drawFieldStrengthCheckbox.checked;
       this.space.drawFieldStrength = drawFieldStrength;

       const drawStarsLine = !! drawStarsLineCheckbox.checked;
       this.space.setDrawStarsLine(drawStarsLine);

       return false;
     };

     this.eventRestartClick = function(e) {
       event.preventDefault();

       this.space.restartStars();

       return false;
     }

   }


   function Space({
     id,
     starCount = 100,
     maxDistance = 100,
     blackHoleGravity = 10,
     drawStarTail = true,
     drawStarsLine = true,
     drawFieldVector = true,
     drawFieldStrength = true,
   }) {

     const canvas = document.getElementById(id);
     const c = canvas.getContext("2d");

     const width = canvas.width;
     const height = canvas.height;

     return {
       starCount: starCount,
       stars: [],
       canvas: canvas,
       c: c,
       width: width,
       height: height,
       maxDistance: maxDistance,
       field: null,
       blackHoleGravity: blackHoleGravity,
       drawStarsLine: drawStarsLine,
       drawFieldVector: drawFieldVector,
       drawFieldStrength: drawFieldStrength,

       passTime: function() {
         this.ensureStarCount();

         this.recreateField();

         for (let star of this.stars) {
           star.changeSpeed(this.field);
         }

         for (let star of this.stars) {
           star.move(this);
         }

         this.draw();
       },

       restartStars: function() {
         this.stars = [];
       },

       ensureStarCount: function() {
         const missingCount = this.starCount - this.stars.length;
         if (missingCount > 0) {
           this.stars.push(
             ... Array(missingCount).fill().map(
               () => new Star({
                 x: Math.floor(Math.random() * this.width),
                 y: Math.floor(Math.random() * this.height),
                 drawTail: this.drawStarTail,
               }),
             )
           );
         }
         else if (missingCount < 0) {
           Array.from({ length: -missingCount }).forEach( () => this.stars.pop() );
         }
       },

       setDrawStarTail: function(value) {
         this.drawStarTail = value;
         this.stars.forEach((star) => star.setDrawTail(value));
       },

       setDrawStarsLine: function(value) {
         //TODO: remove limitation after optimising the O(n**2) stars line
         if (this.starCount > 300) {
           value = false;
         }
         this.drawStarsLine = value;
       },

       recreateField: function() {
         this.field = new Field({
           spaceWidth: this.width,
           spaceHeight: this.height,
           drawVector: this.drawFieldVector,
           drawStrength: this.drawFieldStrength,
         });
         this.field.placeGravityWell(
           Math.ceil((width  / 2) - (this.field.pixelPerLocation / 2)),
           Math.ceil((height / 2) - (this.field.pixelPerLocation / 2)),
           this.blackHoleGravity,
         );

         for (let star of this.stars) {
           this.field.placeGravityWell(star.x, star.y, star.mass);
         }
       },

       draw: function() {
         this.c.clearRect(0, 0, this.canvas.width, this.canvas.height)
         this.field.draw(this);
         this.c.strokeStyle = 'rgb(100, 100, 100)';

         // Draw stars
         for (let star of this.stars) {
           star.draw(this);
         }

         // Draw lines between stars
         if (this.drawStarsLine) {
           this.drawStarLines();
         }
       },

       drawStarLines: function() {

         for (let star1 of this.stars) {
           for (let star2 of this.stars) {
             if (star1 === star2) { continue }
             if (this.isTooFarAway(star1, star2)) { continue }
             this.drawStarLine(star1, star2);
           }
         }
       },

       isTooFarAway: function(star1, star2) {
         const xDistance = Math.abs(star1.x - star2.x);
         if (xDistance > this.maxDistance) return true;

         const yDistance = Math.abs(star1.y - star2.y);
         if (yDistance > this.maxDistance) return true;

         return false;
       },

       drawStarLine: function(star1, star2) {
         this.drawLine(star1.x, star1.y, star2.x, star2.y, "rgb(255, 255, 255, 0.17)");
       },

       drawLine: function(x1, y1, x2, y2, strokeStyle) {
         const c = this.c;
         if (strokeStyle) {
           c.strokeStyle = strokeStyle;
         }
         c.beginPath();
         c.moveTo(x1, y1);
         c.lineTo(x2, y2);
         c.stroke();
         c.closePath();
       }
     };
   }

   function Star({ x, y, color, mass, drawTail }) {
     color = color || 'rgb(200, 200, 200)';

     const randomD = function() {
       const d = ((Math.random() - 0.5) * 0.7);
       return d;
     };
     const dx = randomD();
     const dy = randomD();
     mass = mass || (Math.random() * 5) + 2;
     return {
       x: x,
       y: y,
       color: color,
       dx: dx,
       dy: dy,
       mass: mass,
       drawTail: drawTail,

       move: function(space) {
         this.x = this.moveDimension(this.x, this.dx, space.width);
         this.y = this.moveDimension(this.y, this.dy, space.height);
       },

       moveDimension: function(d, dd, dMax) {
         d += dd;
         if (d < 0) { d = dMax - 1 }
         else if (d > dMax) { d = 0 }
         return d;
       },

       draw: function(space) {
         space.c.fillStyle = this.color;
         const size = this.mass / 2;
         const sizeOffset = size / 2;
         space.c.fillRect(this.x - sizeOffset, this.y - sizeOffset, size, size);

         if (this.drawTail) {
           const tailPoint = this.tailPoint();
           space.drawLine(this.x, this.y, tailPoint.x, tailPoint.y);
         }
       },

       tailPoint: function() {
         return {
           x: this.x - ( this.dx * 15 ),
           y: this.y - ( this.dy * 15 ),
         };
       },

       changeSpeed: function(field) {
         const point = field.pixelToPoint(this.x, this.y);
         this.dx += field.xInfluence(point, this.mass);
         this.dy += field.yInfluence(point, this.mass);
       },

       setDrawTail: function(value) {
         this.drawTail = value;
       }
     };
   }


   function Field({
     spaceWidth,
     spaceHeight,
     drawVector = true,
     drawStrength = true,
   }) {
     const pixelPerLocation = 10;

     const width = Math.floor(spaceWidth / pixelPerLocation);
     const height = Math.floor(spaceHeight / pixelPerLocation);

     const newMatrix = function(value) {
       return Array.from(
         Array(
           width,
         ), () => Array.from( Array(width), () => value ),
       );
     }

     const xMatrix = newMatrix(0);
     const yMatrix = newMatrix(0);

     return {
       width: width,
       height: height,
       xMatrix: xMatrix,
       yMatrix: yMatrix,
       pixelPerLocation: pixelPerLocation,
       drawVector: drawVector,
       drawStrength: drawStrength,

       newMatrix: newMatrix,

       resetMatrix: function() {
         this.xMatrix = newMatrix(1);
         this.yMatrix = newMatrix(0.5);
       },

       xInfluence: function(point, mass) {
         const influence = this.xMatrix[ point[0] ][ point[1] ];
         return influence / mass;
       },
       yInfluence: function(point, mass) {
         const influence = this.yMatrix[ point[0] ][ point[1] ];
         return influence / mass;
       },

       pixelToPoint: function(x, y) {
         return [
           Math.floor(x / pixelPerLocation),
           Math.floor(y / pixelPerLocation),
         ];
       },

       placeGravityWell: function(xCenter, yCenter, mass) {
         const centerPoint = this.pixelToPoint(xCenter, yCenter);
         const radius = Math.max(
           2,
           Math.floor(mass * this.pixelPerLocation / 6), ///JPL: 10
         );
         // console.log(`JPL: mass: ${mass}, radius: ${radius}`);

         const gravityStep = mass / radius;
         let gravity = mass / 1000 * this.pixelPerLocation;
         // console.log("placeGravityWell", { mass: mass, gravityStep: gravityStep, gravity: gravity });
         // Should be radius ** 2 (according to physics)
         for (let r = 1, g = gravity; r < radius; r++, g = gravity / (r ** 1.2)) {
           /* if (g < 0.005) break; */
           this.setMatrixGravityCircle(centerPoint, r, g);
         }
       },

       setMatrixGravityCircle(centerPoint, radius, gravity) {
         // From https://www.mathopenref.com/coordcirclealgorithm.html
         const h = centerPoint[0];
         const k = centerPoint[1];

         ///JPL: increase as radius increases
         const step = 2 * Math.PI / 40; // originally 20
         const r = radius;

         // console.log("setMatrixGravityCircle", { radius: radius, gravity: gravity, step: step });
         for(let theta = 0;  theta < 2 * Math.PI; theta += step) {
           const gx = r * Math.cos(theta);
           const gy = r * Math.sin(theta);
           // Not sure why the adjustment does
           const x = Math.ceil(h + gx - 0.25);
           const y = Math.ceil(k - gy - 0.25);

           // No effect on the point the thing is on, so stars don't affect themselves
           if (x === h && y === k) continue;

           // Point back to centerPoint
           const xGravity = -gx * gravity;
           const yGravity =  gy * gravity;
           this.adjustMatrixGravityAt(x , y,  xGravity, yGravity);
         }
       },

       adjustMatrixGravityAt: function(px, py, dx, dy) {
         if (px < 0 || py < 0 || px >= this.width || py >= this.height) return;
         const divisor = 1; // dx && dy ? 2 : 1; ///JPL: should be something more like sqrt
         this.xMatrix[px][py] += dx / divisor;
         this.yMatrix[px][py] += dy / divisor;
       },

       matrixGravitySizeAt: function(px, py) {
         const dx = this.xMatrix[px][py];
         const dy = this.yMatrix[px][py];
         return Math.sqrt((dx ** 2) + (dy ** 2));
       },

       draw: function(space) {
         for (let px = 0; px < this.width; px++) {
           for (let py = 0; py < this.height; py++) {
             const gravitySize = this.matrixGravitySizeAt(px, py);
             if (!gravitySize) continue;

             this.drawGravitySize(px, py, gravitySize, space);
           }
         }
       },

       drawGravitySize: function(px, py, gravitySize, space) {
         const pixelCount = this.pixelPerLocation;

         const x = px * pixelCount;
         const y = py * pixelCount;

         // Draw strength background
         if (this.drawStrength) {
           const opacity = Math.min(gravitySize / 4, 0.6);
           space.c.fillStyle = `rgba(255, 255, 255, ${opacity})`;
           space.c.fillRect(x, y, pixelCount, pixelCount);
         }

         // Draw vector line
         if (this.drawVector) {
           const xCenter = x + (pixelCount / 2);
           const yCenter = y + (pixelCount / 2);
           const dx = this.xMatrix[px][py] * 100;
           const dy = this.yMatrix[px][py] * 100;
           space.drawLine(xCenter, yCenter, xCenter + dx, yCenter + dy, 'rgb(10, 10, 10)');
         }
       }

     };
   }



   const milkySpace = new Space({
     id: "milky",
     starCount: 25,
     blackHoleGravity: 0,
     drawStarTail: true,
     drawStarsLine: true,
     maxDistance: 60,
     drawFieldVector: true,
     drawFieldStrength: false
   });
   const milkySimulation = new Simulation({
     id: "milky-simulation",
     space: milkySpace,
   });


   const spaces = [
     new Space({
       id: "andromeda",
       starCount: 4,
       maxDistance: 20,
       blackHoleGravity: 4,
     }),
     milkySpace,
   ];

   function passTime() {
     for (let space of spaces) {
       space.passTime();
     }

     window.requestAnimationFrame(passTime);
   }

   passTime();


  </script>
</html>
