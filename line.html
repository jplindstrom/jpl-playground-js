<html>
  <style>
   body {
     background: #000;
   }

   .galaxy {
     margin: 1em;
   }
  </style>

  <body>
    <canvas id="andromeda" class="galaxy" width="100" height="100"></canvas>
    <canvas id="milky" class="galaxy" width="640" height="480"></canvas>
  </body>

  <script>
   "use strict";

   // http://slicker.me/javascript/particles.htm inspired me to do this

   function Space(id, starCount = 100, maxDistance = 100) {

     const canvas = document.getElementById(id);
     const c = canvas.getContext("2d");

     const width = canvas.width;
     const height = canvas.height;

     const field = new Field(width, height);
     field.placeGravityWell(width / 2, height / 2, 10);

     const stars = Array(starCount).fill().map(
       () => new Star(
         Math.floor(Math.random() * width),
         Math.floor(Math.random() * height),
       ),
     );

     return {
       stars: stars,
       canvas: canvas,
       c: c,
       width: width,
       height: height,
       maxDistance: maxDistance,
       field: field,

       passTime: function() {
         for (let star of this.stars) {
           star.changeSpeed(this.field);
         }

         for (let star of this.stars) {
           star.move(this);
         }

         this.draw();
       },

       draw: function() {
         this.c.clearRect(0, 0, this.canvas.width, this.canvas.height)
         this.field.draw(this);
         this.c.strokeStyle = 'rgb(100, 100, 100)';

         // Draw stars
         for (let star of this.stars) {
           star.draw(this);
         }

         // Draw lines between stars
         this.drawStarLines();
       },

       drawStarLines: function() {

         for (let star1 of this.stars) {
           for (let star2 of this.stars) {
             if (star1 === star2) { continue }
             if (this.isTooFarAway(star1, star2)) { continue }
             this.drawStarLine(star1, star2);
           }
         }
       },

       isTooFarAway: function(star1, star2) {
         const xDistance = Math.abs(star1.x - star2.x);
         if (xDistance > this.maxDistance) return true;

         const yDistance = Math.abs(star1.y - star2.y);
         if (yDistance > this.maxDistance) return true;

         return false;
       },

       drawStarLine: function(star1, star2) {
         this.drawLine(star1.x, star1.y, star2.x, star2.y);
       },

       drawLine: function(x1, y1, x2, y2) {
         const c = this.c;
         c.beginPath();
         c.moveTo(x1, y1);
         c.lineTo(x2, y2);
         c.stroke();
         c.closePath();
       }
     };
   }

   function Star(x, y, color = 'rgb(200, 200, 200)', mass) {
     const randomD = function() {
       const d = ((Math.random() - 0.5) * 0.7);
       return d;
     };
     const dx = randomD();
     const dy = randomD();
     mass = mass || Math.random() * 5 + 3;
     return {
       x: x,
       y: y,
       color: color,
       dx: dx,
       dy: dy,
       mass: mass,

       move: function(space) {
         this.x = this.moveDimension(this.x, this.dx, space.width);
         this.y = this.moveDimension(this.y, this.dy, space.height);
       },

       moveDimension: function(d, dd, dMax) {
         d += dd;
         if (d < 0) { d = dMax - 1 }
         else if (d > dMax) { d = 0 }
         return d;
       },

       draw: function(space) {
         space.c.fillStyle = this.color;
         const size = this.mass / 2;
         const sizeOffset = size / 2;
         space.c.fillRect(this.x - sizeOffset, this.y - sizeOffset, size, size);

         const tailPoint = this.tailPoint();
         space.drawLine(this.x, this.y, tailPoint.x, tailPoint.y);
       },

       tailPoint: function() {
         return {
           x: this.x - ( this.dx * 20 ),
           y: this.y - ( this.dy * 20 ),
         };
       },

       changeSpeed: function(field) {
         const point = field.pixelToPoint(this.x, this.y);
         this.dx += field.xInfluence(point, this.mass);
         this.dy += field.yInfluence(point, this.mass);
       },
     };
   }


   function Field(spaceWidth, spaceHeight) {
     const pixelPerLocation = 20;

     const width = Math.floor(spaceWidth / pixelPerLocation);
     const height = Math.floor(spaceHeight / pixelPerLocation);

     const newMatrix = function(value) {
       return Array.from(
         Array(
           width,
         ), () => Array.from( Array(width), () => value ),
       );
     }

     const xMatrix = newMatrix(0);
     const yMatrix = newMatrix(0);

     return {
       width: width,
       height: height,
       xMatrix: xMatrix,
       yMatrix: yMatrix,
       pixelPerLocation: pixelPerLocation,

       newMatrix: newMatrix,

       resetMatrix: function() {
         this.xMatrix = newMatrix(1);
         this.yMatrix = newMatrix(0.5);
       },

       xInfluence: function(point, mass) {
         const influence = this.xMatrix[ point[0] ][ point[1] ];
         return influence / mass;
       },
       yInfluence: function(point, mass) {
         const influence = this.yMatrix[ point[0] ][ point[1] ];
         return influence / mass;
       },

       pixelToPoint: function(x, y) {
         return [
           Math.floor(x / pixelPerLocation),
           Math.floor(y / pixelPerLocation),
         ];
       },

       placeGravityWell: function(xCenter, yCenter, mass) {
         const centerPoint = this.pixelToPoint(xCenter, yCenter);
         const radius = Math.floor(mass / 10);

         const gravityStep = mass / radius;
         let gravity = mass / 100;
         for (let r = 0; r < radius; r++, gravity += gravityStep) {
           this.setMatrixGravityCircle(centerPoint, r, gravity);
           break; ///JPL only do this once until we're drawing a circle
         }
       },

       setMatrixGravityCircle(centerPoint, radius, gravity) {
         const x = centerPoint[0];
         const y = centerPoint[1];
         const g = gravity;
         this.adjustMatrixGravityAt(x    , y - 1,  0, +g); // top
         this.adjustMatrixGravityAt(x + 1, y - 1, -g, +g); // top right
         this.adjustMatrixGravityAt(x + 1, y    , -g,  0); // right
         this.adjustMatrixGravityAt(x + 1, y + 1, -g, -g); // bottom right
         this.adjustMatrixGravityAt(x    , y + 1,  0, -g); // bottom
         this.adjustMatrixGravityAt(x - 1, y + 1, -g,  g); // bottom left
         this.adjustMatrixGravityAt(x - 1, y    , +g,  0); // left
         this.adjustMatrixGravityAt(x - 1, y - 1, +g, +g); // top left
       },

       adjustMatrixGravityAt: function(px, py, dx, dy) {
         const divisor = dx && dy ? 2 : 1;
         this.xMatrix[px][py] += dx / divisor;
         this.yMatrix[px][py] += dy / divisor;
       },

       matrixGravitySizeAt: function(px, py) {
         return Math.abs(this.xMatrix[px][py]) + Math.abs(this.yMatrix[px][py]);
       },

       draw: function(space) {
         for (let px = 0; px < this.width; px++) {
           for (let py = 0; py < this.height; py++) {
             const gravitySize = this.matrixGravitySizeAt(px, py);
             if (!gravitySize) continue;

             this.drawGravitySize(px, py, gravitySize, space);
           }
         }
       },

       drawGravitySize: function(px, py, gravitySize, space) {
         const x = px * this.pixelPerLocation;
         const y = py * this.pixelPerLocation;
         const opacity = Math.abs(gravitySize);
         space.c.fillStyle = `rgba(255, 255, 255, ${opacity})`;
         space.c.fillRect(x, y, this.pixelPerLocation, this.pixelPerLocation);
       }

     };
   }



   const galaxies = [
     new Space("andromeda", 10, 30),
     new Space("milky", 30, 100),
   ];

   function passTime() {
     for (let galaxy of galaxies) {
       galaxy.passTime();
     }

     window.requestAnimationFrame(passTime);
   }

   passTime();


  </script>
</html>
